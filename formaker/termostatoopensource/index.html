<!DOCTYPE html><!--

  Instructions:

  - Save this file.
  - Replace "USER" with your GitHub username.
  - Replace "REPO" with your GitHub repo name.
  - Replace "Your Project" with your project name.
  - Upload this file (or commit to GitHub Pages).

  Customize as you see fit!

--><html><head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">

    <title>Rotilio thermo - termostato open source</title>

    <!-- Flatdoc -->
    <script async="" src="https://www.google-analytics.com/analytics.js"></script><script async="" charset="utf-8" src="https://v2.zopim.com/?4mWCOhTZkvtJza92XbR7FDRazylxzBJu" type="text/javascript"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/legacy.js"></script>
    <script src="https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/flatdoc.js"></script>

    <!-- Flatdoc theme -->
    <link href="https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/style.css" rel="stylesheet">
    <script src="https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/script.js"></script>

    <!-- Meta -->
    <meta content="Rotilio thermo - termostato open source" property="og:title">
    <meta content="Questo è un tutorial per costruire un termostato open source, personalizzabile, economico, intelligente. Troverete tutte le componenti e i passaggi per costruirlo, scrivere il firwmare e l'APP Mobile" name="description">

    <!-- Initializer -->
    <script>
        Flatdoc.run({
            //fetcher: Flatdoc.file('README.md')
            fetcher: Flatdoc.github('techmakers/rotiliothermo', 'README.md')
        });
    </script>


    <!--Start of Zendesk Chat Script-->
    <script type="text/javascript">
        window.$zopim || (function (d, s) {
            var z = $zopim = function (c) {
                z._.push(c)
            }, $ = z.s =
                    d.createElement(s), e = d.getElementsByTagName(s)[0];
            z.set = function (o) {
                z.set._.push(o)
            };
            z._ = [];
            z.set._ = [];
            $.async = !0;
            $.setAttribute('charset', 'utf-8');
            $.src = 'https://v2.zopim.com/?4mWCOhTZkvtJza92XbR7FDRazylxzBJu';
            z.t = +new Date;
            $.type = 'text/javascript';
            e.parentNode.insertBefore($, e)
        })(document, 'script');
    </script>
    <!--End of Zendesk Chat Script-->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-101546095-1', 'auto');
        ga('send', 'pageview');

    </script>


    <style media="print" class="jx_ui_StyleSheet" __jx__id="___$_2" type="text/css">.zopim { display: none !important }</style></head>
<body role="flatdoc"><div class="zopim" __jx__id="___$_62 ___$_62" data-test-id="ChatWidgetButton" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px; border: 0px; background-color: transparent; overflow: hidden; position: fixed; z-index: 16000002; width: 205px; height: 30px; right: 10px; bottom: 0px; background-position: initial initial; background-repeat: initial initial;"><iframe seamless="" frameborder="0" src="about:blank" style="background-color: transparent; vertical-align: text-bottom; position: relative; width: 100%; height: 100%; min-width: 100%; min-height: 100%; max-width: 100%; max-height: 100%; margin: 0px; overflow: hidden; display: block;" data-test-id="ChatWidgetButton-iframe"></iframe></div><div class="zopim" __jx__id="___$_4 ___$_4" data-test-id="ChatWidgetWindow" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; padding: 0px; border: 0px; background-color: transparent; overflow: hidden; position: fixed; z-index: 16000001; right: 10px; bottom: 0px; border-top-left-radius: 5px; border-top-right-radius: 5px; display: none; width: 290px; height: 400px; -webkit-box-shadow: rgba(0, 0, 0, 0.0980392) 0px 0px 3px 2px; box-shadow: rgba(0, 0, 0, 0.0980392) 0px 0px 3px 2px; background-position: initial initial; background-repeat: initial initial;"><iframe seamless="" frameborder="0" src="about:blank" data-test-id="ChatWidgetWindow-iframe" style="background-color: transparent; vertical-align: text-bottom; position: relative; width: 100%; height: 100%; min-width: 100%; min-height: 100%; max-width: 100%; max-height: 100%; margin: 0px; overflow: hidden; display: block;"></iframe></div>

<div class="header">
    <div class="left">
        <h1><img style="margin-right:5px;width:20px;vertical-align: middle" src="https://techmakers.io/formaker/img/TechmakersLogo.png">Rotilio thermo - termostato open source</h1>
        <ul>
            <li><a href="https://github.com/techmakers/rotiliothermo">View on GitHub</a></li>
            <li><a href="https://github.com/techmakers/rotiliothermo/issues">Issues</a></li>
            <li><a href="https://techmakers.io">a project by Techmakers srl</a></li>
        </ul>
    </div>
    <div class="right">
        <!-- GitHub buttons: see http://ghbtns.com -->
        <iframe src="https://ghbtns.com/github-btn.html?user=techmakers&amp;repo=rotiliothermo&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
    </div>
</div>

<div class="content-root">
    <div class="menubar fixed">
        <div class="menu section" role="flatdoc-menu"><ul><li id="root-item" class="level-0"><ul class="level-1" id="root-list"><li id="rotilio-thermo-item" class="level-1"><a id="rotilio-thermo-link" href="#rotilio-thermo" class="level-1">Rotilio Thermo</a><ul class="level-2" id="rotilio-thermo-list"><li id="rotilio-thermo-componenti-principali-item" class="level-2"><a id="rotilio-thermo-componenti-principali-link" href="#rotilio-thermo-componenti-principali" class="level-2">Componenti principali</a><ul class="level-3" id="rotilio-thermo-componenti-principali-list"><li id="rotilio-thermo-componenti-principali-sistema-di-riscaldamento-item" class="level-3"><a id="rotilio-thermo-componenti-principali-sistema-di-riscaldamento-link" href="#rotilio-thermo-componenti-principali-sistema-di-riscaldamento" class="level-3">Sistema di riscaldamento</a></li><li id="rotilio-thermo-componenti-principali-app-mobile-versione-1-item" class="level-3"><a id="rotilio-thermo-componenti-principali-app-mobile-versione-1-link" href="#rotilio-thermo-componenti-principali-app-mobile-versione-1" class="level-3">App Mobile, versione 1</a></li><li id="rotilio-thermo-componenti-principali-app-mobile-versione-2-item" class="level-3"><a id="rotilio-thermo-componenti-principali-app-mobile-versione-2-link" href="#rotilio-thermo-componenti-principali-app-mobile-versione-2" class="level-3">App Mobile, versione 2</a></li><li id="rotilio-thermo-componenti-principali-dispositivo-iot-rotilio-maker-item" class="level-3"><a id="rotilio-thermo-componenti-principali-dispositivo-iot-rotilio-maker-link" href="#rotilio-thermo-componenti-principali-dispositivo-iot-rotilio-maker" class="level-3">Dispositivo IoT Rotilio Maker</a></li><li id="rotilio-thermo-componenti-principali-particle-cloud-item" class="level-3"><a id="rotilio-thermo-componenti-principali-particle-cloud-link" href="#rotilio-thermo-componenti-principali-particle-cloud" class="level-3">Particle Cloud</a></li><li id="rotilio-thermo-componenti-principali-firmware-item" class="level-3"><a id="rotilio-thermo-componenti-principali-firmware-link" href="#rotilio-thermo-componenti-principali-firmware" class="level-3">Firmware</a></li></ul></li><li id="rotilio-thermo-tecnologie-item" class="level-2"><a id="rotilio-thermo-tecnologie-link" href="#rotilio-thermo-tecnologie" class="level-2">Tecnologie</a><ul class="level-3" id="rotilio-thermo-tecnologie-list"><li id="rotilio-thermo-tecnologie-meteor-item" class="level-3"><a id="rotilio-thermo-tecnologie-meteor-link" href="#rotilio-thermo-tecnologie-meteor" class="level-3">Meteor</a></li><li id="rotilio-thermo-tecnologie-paricleio-item" class="level-3"><a id="rotilio-thermo-tecnologie-paricleio-link" href="#rotilio-thermo-tecnologie-paricleio" class="level-3">Paricle.io</a></li><li id="rotilio-thermo-tecnologie-rotilio-maker-item" class="level-3"><a id="rotilio-thermo-tecnologie-rotilio-maker-link" href="#rotilio-thermo-tecnologie-rotilio-maker" class="level-3">Rotilio Maker</a></li><li id="rotilio-thermo-tecnologie-breve-panoramica-sulle-componenti-che-useremo-in-rotilio-maker-item" class="level-3"><a id="rotilio-thermo-tecnologie-breve-panoramica-sulle-componenti-che-useremo-in-rotilio-maker-link" href="#rotilio-thermo-tecnologie-breve-panoramica-sulle-componenti-che-useremo-in-rotilio-maker" class="level-3">Breve panoramica sulle componenti che useremo in Rotilio Maker.</a></li></ul></li><li id="rotilio-thermo-requisiti-necessari-item" class="level-2"><a id="rotilio-thermo-requisiti-necessari-link" href="#rotilio-thermo-requisiti-necessari" class="level-2">Requisiti necessari</a><ul class="level-3" id="rotilio-thermo-requisiti-necessari-list"><li id="rotilio-thermo-requisiti-necessari-rotilio-maker-item" class="level-3"><a id="rotilio-thermo-requisiti-necessari-rotilio-maker-link" href="#rotilio-thermo-requisiti-necessari-rotilio-maker" class="level-3">Rotilio Maker</a></li><li id="rotilio-thermo-requisiti-necessari-particleio-photon-item" class="level-3"><a id="rotilio-thermo-requisiti-necessari-particleio-photon-link" href="#rotilio-thermo-requisiti-necessari-particleio-photon" class="level-3">Particle.io Photon</a></li><li id="rotilio-thermo-requisiti-necessari-rotilio-maker-kit-item" class="level-3"><a id="rotilio-thermo-requisiti-necessari-rotilio-maker-kit-link" href="#rotilio-thermo-requisiti-necessari-rotilio-maker-kit" class="level-3">Rotilio Maker Kit</a></li></ul></li><li id="rotilio-thermo-primi-passi-item" class="level-2"><a id="rotilio-thermo-primi-passi-link" href="#rotilio-thermo-primi-passi" class="level-2">Primi passi</a><ul class="level-3" id="rotilio-thermo-primi-passi-list"><li id="rotilio-thermo-primi-passi-il-firmware-item" class="level-3"><a id="rotilio-thermo-primi-passi-il-firmware-link" href="#rotilio-thermo-primi-passi-il-firmware" class="level-3">Il firmware</a></li><li id="rotilio-thermo-primi-passi-come-rendere-leggibile-una-variabile-item" class="level-3"><a id="rotilio-thermo-primi-passi-come-rendere-leggibile-una-variabile-link" href="#rotilio-thermo-primi-passi-come-rendere-leggibile-una-variabile" class="level-3">Come rendere leggibile una variabile.</a></li><li id="rotilio-thermo-primi-passi-caricare-il-firmware-sul-vostro-rotilio-maker-item" class="level-3"><a id="rotilio-thermo-primi-passi-caricare-il-firmware-sul-vostro-rotilio-maker-link" href="#rotilio-thermo-primi-passi-caricare-il-firmware-sul-vostro-rotilio-maker" class="level-3">Caricare il firmware sul vostro Rotilio Maker</a></li><li id="rotilio-thermo-primi-passi-accesso-al-cloud-di-particleio-item" class="level-3"><a id="rotilio-thermo-primi-passi-accesso-al-cloud-di-particleio-link" href="#rotilio-thermo-primi-passi-accesso-al-cloud-di-particleio" class="level-3">Accesso al cloud di Particle.io</a></li><li id="rotilio-thermo-primi-passi-test-delle-variabili-item" class="level-3"><a id="rotilio-thermo-primi-passi-test-delle-variabili-link" href="#rotilio-thermo-primi-passi-test-delle-variabili" class="level-3">Test delle variabili</a></li><li id="rotilio-thermo-primi-passi-inviare-comandi-al-dispositivo-item" class="level-3"><a id="rotilio-thermo-primi-passi-inviare-comandi-al-dispositivo-link" href="#rotilio-thermo-primi-passi-inviare-comandi-al-dispositivo" class="level-3">Inviare comandi al dispositivo</a></li></ul></li><li id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-item" class="level-2"><a id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-link" href="#rotilio-thermo-testiamo-il-nostro-termostato-opensource" class="level-2">Testiamo il nostro termostato opensource</a><ul class="level-3" id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-list"><li id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-sequenza-di-test-software-item" class="level-3"><a id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-sequenza-di-test-software-link" href="#rotilio-thermo-testiamo-il-nostro-termostato-opensource-sequenza-di-test-software" class="level-3">Sequenza di test software</a></li><li id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-test-hardware-item" class="level-3"><a id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-test-hardware-link" href="#rotilio-thermo-testiamo-il-nostro-termostato-opensource-test-hardware" class="level-3">Test hardware</a></li></ul></li><li id="rotilio-thermo-collegamento-del-sistema-di-riscaldamento-item" class="level-2"><a id="rotilio-thermo-collegamento-del-sistema-di-riscaldamento-link" href="#rotilio-thermo-collegamento-del-sistema-di-riscaldamento" class="level-2">Collegamento del sistema di riscaldamento</a></li><li id="rotilio-thermo-cosa-abbiamo-imparato-item" class="level-2"><a id="rotilio-thermo-cosa-abbiamo-imparato-link" href="#rotilio-thermo-cosa-abbiamo-imparato" class="level-2">Cosa abbiamo imparato</a></li><li id="rotilio-thermo-prossimi-passi-item" class="level-2"><a id="rotilio-thermo-prossimi-passi-link" href="#rotilio-thermo-prossimi-passi" class="level-2">Prossimi passi</a><ul class="level-3" id="rotilio-thermo-prossimi-passi-list"><li id="rotilio-thermo-prossimi-passi-stabilizzare-la-lettura-della-temperatura-item" class="level-3"><a id="rotilio-thermo-prossimi-passi-stabilizzare-la-lettura-della-temperatura-link" href="#rotilio-thermo-prossimi-passi-stabilizzare-la-lettura-della-temperatura" class="level-3">Stabilizzare la lettura della temperatura</a></li><li id="rotilio-thermo-prossimi-passi-proteggiamo-il-ciclo-di-accensione-e-spegnimento-item" class="level-3"><a id="rotilio-thermo-prossimi-passi-proteggiamo-il-ciclo-di-accensione-e-spegnimento-link" href="#rotilio-thermo-prossimi-passi-proteggiamo-il-ciclo-di-accensione-e-spegnimento" class="level-3">Proteggiamo il ciclo di accensione e spegnimento</a></li><li id="rotilio-thermo-prossimi-passi-inviamo-un-evento-sul-cloud-quando-accendiamo-o-spegnamo-il-riscaldamento-item" class="level-3"><a id="rotilio-thermo-prossimi-passi-inviamo-un-evento-sul-cloud-quando-accendiamo-o-spegnamo-il-riscaldamento-link" href="#rotilio-thermo-prossimi-passi-inviamo-un-evento-sul-cloud-quando-accendiamo-o-spegnamo-il-riscaldamento" class="level-3">Inviamo un evento sul cloud quando accendiamo o spegnamo il riscaldamento</a></li></ul></li><li id="rotilio-thermo-lapp-mobile-item" class="level-2"><a id="rotilio-thermo-lapp-mobile-link" href="#rotilio-thermo-lapp-mobile" class="level-2">L’APP Mobile</a></li></ul></li></ul></li></ul></div>
    </div>
    <div role="flatdoc-content" class="content"><h1 id="rotilio-thermo">Rotilio thermo - termostato open source</h1><p>Un termostato open source, personalizzabile, economico, intelligente.</p><p>Questo tutorial ti permetterà di realizzare un termostato per il riscaldamento di casa e ufficio, controllato da remoto, attraverso una App Mobile per iOS e Android.</p><p>Ecco gli step principali di questo tutorial:</p><ul>
        <li>capiamo quali strumenti sono necessari</li>
        <li>parliamo di hardware connesso e sensori</li>
        <li>iniziamo a scrivere il firmware</li>
        <li>connettiamo il dispositivo al cloud</li>
        <li>affiniamo il controllo di temperatura</li>
        <li>colleghiamo il dispositivo al sistema di riscaldamento</li>
    </ul><p>Ecco cosa imparerai:</p><ul>
        <li>a scrivere software funzionale, espandibile, orientato agli ultimi standard di programmazione</li>
        <li>a controllare oggetti fisici mediante APP e browser WEB</li>
        <li>a integrare fra loro servizi WEB per creare un ecosistema funzionale e aperto</li>
    </ul><p>Dato che il software nel mondo IoT interagisce con il mondo fisico, ecco cosa altro imparerai:</p><ul>
        <li>a scrivere software che considera gli <code>errori</code> del sistema</li>
        <li>a proteggere il sistema da eventuali errori, siano essi di lettura dell’ambiente che umani</li>
        <li>ad azionare meccanismi solo quando serve, senza sprechi di energia</li>
    </ul><p>Questa è anche l’occasione per esplorare tutte le possibilità offerte da <a href="https://techmakers.io/rotilio-maker.html">Rotilio Maker</a>, la nostra piattaforma di sviluppo IoT basata su Photon/Electron di <a href="https://particle.io">Particle.io</a>.</p><h2 id="rotilio-thermo-componenti-principali">Componenti principali</h2><h3 id="rotilio-thermo-componenti-principali-sistema-di-riscaldamento">Sistema di riscaldamento</h3><p>E’ l’oggetto che andremo a controllare. Questo progetto funziona per tutti gli impianti di riscaldamento in cui esiste un termostato che apre o chiude un circuito collegato alla caldaia.
        A seconda dei casi, la caldaia inizia a scaldare quando il circuito si chiude o si apre. Il progetto è compatibile con entrambi i tipi di caldaia.
        Il collegamento quindi avviene tra il relè di Rotilio Maker e la caldaia.
        Anche il tradizionale cronotermostato ha un relè, Rotilio Maker quindi si può sostituire al cronotermostato molto facilmente.
        Ci sono due modi di collegare Rotilio Maker:</p><ul>
        <li>sostituendo completamente il cronotermostato</li>
        <li>affiancandolo, con un collegamento in parallelo </li>
    </ul><h3 id="rotilio-thermo-componenti-principali-app-mobile-versione-1">App Mobile, versione 1</h3><p>L’App Mobile è lo strumento che permette di interagire con il sistema. Deve presentare, almeno per iniziare, le seguenti funzionalità:</p><ul>
        <li>Accensione e spegnimento manuale del riscaldamento, con regolazione della temperatura desiderata</li>
        <li>Indicazioni sullo stato attuale del sistema: temperatura, stato di marcia, connessione</li>
        <li>Possibilità di gestire più sistemi di riscaldamento (casa, ufficio, casa al mare, casa in montagna)</li>
    </ul><h3 id="rotilio-thermo-componenti-principali-app-mobile-versione-2">App Mobile, versione 2</h3><p>Consolidato il funzionamento di base potremo inserire funzionalità evolute nel nostro sistema, come ad esempio la programmazione del termostato con giorni della settimana, orari e temperature.</p><h3 id="rotilio-thermo-componenti-principali-dispositivo-iot-rotilio-maker">Dispositivo IoT Rotilio Maker</h3><p><a href="https://techmakers.io/rotilio-maker.html">Rotilio Maker</a> ospita il <a href="https://it.wikipedia.org/wiki/Sensore">sensore</a> di temperatura che ci permette di capire se è il momento o meno di accendere la caldaia. Inoltre è presente un <a href="https://it.wikipedia.org/wiki/Rel%C3%A8">relè</a> bistabile che funge da attuatore, inviando alla caldaia il comando di accensione o spegnimento.</p><h3 id="rotilio-thermo-componenti-principali-particle-cloud">Particle Cloud</h3><p>Il Cloud di <a href="https://particle.io">Particle.io</a> è una componente utilissima perchè permette di gestire la connessione al dispositivo con estrema semplicità e in tutta sicurezza. Inoltre ci permetterà di aggiornare il firmware del dispositivo anche da remoto, per quei dispositivi già installati in loco, a cui vorremo inviare modifiche successive del software.</p><h3 id="rotilio-thermo-componenti-principali-firmware">Firmware</h3><p>Il firmware è il programma che andremo ad inserire nella CPU del dispositivo IoT Rotilio Maker. Si occuperà di molti aspetti: comunicazione con il cloud, invio della temperatura e dello stato di funzionamento del sistema, ricezione dei comandi di accensione e spegnimento del riscaldamento.  </p><h2 id="rotilio-thermo-tecnologie">Tecnologie</h2><p>Tutto questo è possibile perchè le tecnologie impiegate sono semplici, facilmente disponibili (open source) e molto ben documentate.
        Inoltre l’hardware è iper collaudato.</p><h3 id="rotilio-thermo-tecnologie-meteor">Meteor</h3><p>Per rendere il più universale possibile questo progetto abbiamo scelto di sviluppare il codice lato APP e lato SERVER totalmente in Javascript.</p><p><a href="https://www.meteor.com">Meteor</a> è il framework Javascript che attualmente presenta il compromesso migliore tra portabilità, velocità di sviluppo e affidabilità di esecuzione sul maggior numero di piattaforme.</p><h3 id="rotilio-thermo-tecnologie-paricleio">Paricle.io</h3><p><a href="https://particle.io">Particle.io</a> è un ottimo partner per sviluppare dispositivi connessi. Tutte le problematiche di sicurezza, connessione e aggiornamento del dispositivo sono risolte direttamente nell’ecosistema messo a disposizione da questa (ormai ex) start-up Californiana, che produce software e dispositivi IoT.
        Il codice che produrremo lato dispositivo (firmware) è scritto in Wiring(R), compatibile Arduino(R).</p><h3 id="rotilio-thermo-tecnologie-rotilio-maker">Rotilio Maker</h3><p><a href="https://techmakers.io/rotilio-maker.html">Rotilio Maker</a> è un prodotto IoT pensato per chi vuole realizzare progetti maker ma anche per chi vuole intraprendere il cammino di realizzazione di prodotti connessi, quindi lo abbiamo equipaggiato con componenti utili in molti progetti IoT, ma è possibile espanderlo a seconda delle esigenze.
        Questo permette ad un qualunque sviluppatore di software di leggere una temperatura o attivare un relè, con una sola semplice chiamata https, come se si navigasse una pagina WEB.</p><p>Facciamo un esempio, tanto per entrare nel vivo.</p><p>Inseriamo nella barra degli indirizzi del browser questo <a href="https://api.particle.io/v1/devices/420026001147343339383037/status?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c">URL</a>:</p><pre><code>https://api.particle.io/v1/devices/420026001147343339383037/status?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c</code></pre><p>Otterremo la seguente risposta dal Rotilio Maker presente nel nostro laboratorio (se non dovesse rispondere, <a href="mailto:support@techmakers.io">mandateci una email</a> o <a href="tel:0108315289">chiamateci</a>, ve lo accendiamo noi):</p><pre><code>{
    "cmd": "VarReturn",
    "name": "status",
    "result": {
        "dimmer": 0,
        "temperature": 24,
        "exttemp": 24.39,
        "humidity": 68,
        "pressure": 1006.049988,
        "photoresistor": 4069,
        "trimmer": 2758,
        "deltalight": 1311,
        "button1": 0,
        "button2": 0,
        "switch": 0,
        "relais": 0,
        "alarm": 0
    },
    "coreInfo": {
        "last_app": "",
        "last_heard": "2017-09-16T12:02:34.553Z",
        "connected": true,
        "last_handshake_at": "2017-09-16T11:37:25.199Z",
        "deviceID": "420026001147343339383037",
        "product_id": 6
    }
}</code></pre><h3 id="rotilio-thermo-tecnologie-breve-panoramica-sulle-componenti-che-useremo-in-rotilio-maker">Breve panoramica sulle componenti che useremo in Rotilio Maker.</h3><p>Rotilio Maker è provvisto di sensori di temperatura, umidità, pressione, luce, pulsanti, trimmer, relè buzzer, connettori di espansione e morsetti vari.</p><p>Le componenti che andremo ad utilizzare per questo progetto sono:</p><ul>
        <li>Connettore di espansione per l’alloggiamento del Photon di Particle.io</li>
        <li>Morsetto per alimentazione</li>
        <li>Relè, con connessione ad apposito morsetto</li>
        <li>Sensore di temperatura</li>
    </ul><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/RotilioThermoPictures.001.png" alt="Rotilio Maker Explained"></p><h2 id="rotilio-thermo-requisiti-necessari">Requisiti necessari</h2><p>Per iniziare occorre dotarsi di alcuni strumenti, se state leggendo questo tutorial su un computer desktop, PC o MAC che sia, siete già a buon punto. Il vostro computer, se dotato di connessione Internet, è pronto per inziare il lavoro.</p><p>Poi vi occorre un Rotilio Maker con un Photon, oppure un kit completo di tutto: Rotilio Maker, Photon, Scatola con flangia da parete e alimentatore per realizzare questo progetto.</p><p>Potete procurarvi i componenti singolarmente, se invece preferite abbreviare i tempi, ottimizzare i costi di spedizione e concentrarvi più sul software e le finezze, con il nostro kit siete a posto.</p><p>Dove procurarsi i componenti singoli:</p><h3 id="rotilio-thermo-requisiti-necessari-rotilio-maker">Rotilio Maker</h3><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/RotilioMaker150.png" alt="Rotilio Maker"></p><p>Presso il nostro shop online: <a href=""></a><a href="http://techmakers.io/rotilio-maker.html">http://techmakers.io/rotilio-maker.html</a></p><h3 id="rotilio-thermo-requisiti-necessari-particleio-photon">Particle.io Photon</h3><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/Photon.jpg" alt="Particle.io Photon"></p><p>Presso lo shop online di particle: <a href=""></a><a href="https://store.particle.io/collections/photon">https://store.particle.io/collections/photon</a></p><h3 id="rotilio-thermo-requisiti-necessari-rotilio-maker-kit">Rotilio Maker Kit</h3><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/RotilioMakerKit.png" alt="Rotilio Maker Kit"></p><p>Presso il notro shop online: <a href=""></a><a href="http://techmakers.io/rotilio-maker-kit.html">http://techmakers.io/rotilio-maker-kit.html</a></p><h2 id="rotilio-thermo-primi-passi">Primi passi</h2><p>Il nostro obiettivo è quello di regolare la temperatura di casa o ufficio con impostazioni inviate da remoto.</p><p>La regolazione nel normale cronotermostato avviene misurando la temperatura ad un prestabilito intervallo di tempo, solitamente trenta secondi, o un minuto.
        Se la temperatura è inferiore a quella richiesta, allora azioniamo la caldaia, altrimenti no.</p><p>Il cronotermostato esegue questo ciclo all’infinito, occorre però precisare che l’azionamento della caldaia viene eseguito dal cronotermostato solo se l’impostazione principale è: riscaldamento acceso.</p><p>Se vogliamo riprodurre questo funzionamento abbiamo bisogno di:</p><ul>
        <li>un sensore di temperatura</li>
        <li>un relè (posizione A: caldaia abilitata, posizione B: caldaia disabilitata)</li>
        <li>una CPU</li>
    </ul><p>Iniziamo a scrivere un firmware che permetta al dispositivo Rotilio Maker di interagire con l’ambiente circostante misurando la temperatura e accendendo o meno la caldaia. Completato il firmware scriveremo una APP Mobile per poter interagire con i dispositivi.</p><h3 id="rotilio-thermo-primi-passi-il-firmware">Il firmware</h3><p>Il firmware che gira nella CPU di Rotilio Maker esegue due funzioni: <code>setup</code> e <code>loop</code>.
        La prima viene eseguita solo una volta, all’avviamento della CPU (quando Rotilio Maker viene alimentato), la seconda gira in un ciclo infinito (loop).</p><p>Per ogni esecuzione di <code>loop</code> dovremo:</p><ol>
        <li>leggere la temperatura interrogando l’apposito sensore</li>
        <li>se la temperatura è inferiore a quella impostata ed è richiesto il riscaldamento, azionare il relè portandolo in posizione A, altrimenti azionare il relè in posizione B.</li>
        <li>attendere 30 secondi</li>
    </ol><p>Vediamo un esempio di pseudo-codice Wiring(R) compatibile Arduino(R) che possa eseguire quanto sopra (scriviamo il codice sempre in inglese).</p><pre><code>bool    heaterOn    = true  ;    // running mode
double  T           = 0.0   ;    // temperature from sensor °C
double  Ts          = 18.0  ;    // temperature setup °C
int     period      = 30000 ;    // milliseconds between each loop
int     relaisAorB  = 0     ;    // relais position: A=1, B=0, default B

void loop(){

    T = readTemperatureFromSensor() ;  // acquire actual temperature

    if (heaterOn &amp;&amp; T &lt; Ts) {
        relaisAorB = 1 ;       // actual temperature lower than desired, enable heating system
    } else {
        relaisAorB = 0 ;       // actual temperature ok, disable heating system
    }

    if (relaisAorB == 1) {
        relaisSet();           // switch relais to position A
    } else {
        relaisReset();         // switch ralais to position B
    }

    delay(period);            // wait for the next cycle

}</code></pre><p>La funzione <code>readTemperatureSensor</code> interroga il sensore di temperatura e restituisce la temperatura letta, che verrà memorizzata nella variabile T.</p><p>La funzione <code>relaisSet</code> imposta il relè in posizione A.</p><p>La funzione <code>relaisReset</code> imposta il relè in posizione B.</p><p>La funzione <code>delay</code> attende il numero di secondi (in questo caso 30) ricevuti in input prima di proseguire nell’esecuzione.</p><p>La funzione <code>loop</code> viene eseguita dalla CPU all’infinito.</p><p>Le funzioni <code>delay</code> e <code>loop</code> sono predefinite, mentre le altre tre <code>readTemperatureFromSensor</code>, <code>relaisSet</code> e <code>relaisReset</code> devono essere scritte appositamente, in funzione delle componenti e dei cablaggi eseguiti tra loro.</p><p>Alla pagina GitHub: <a href=""></a><a href="https://github.com/techmakers/rotilio.cc/tree/master/RotilioMaker">https://github.com/techmakers/rotilio.cc/tree/master/RotilioMaker</a> si trovano tutte le info necessarie per capire come scrivere le suddette funzioni.</p><h4>Partiamo dal relè</h4><p>Il classico relè è un interruttore comandato elettricamente. Questo significa che per cambiare la sua posizione da A a B occorre inviargli un segnale elettrico. Nel caso di Rotilio Maker, il relè è connesso ai PIN del Photon D4 e D3. Il PIN D4 è connesso al piedino di <code>set</code> mentre il PIN D3 è connesso al piedino <code>reset</code> del relè.</p><p>Questo significa che per portare il relè in posizione A dobbiamo “alzare” il piedino D4. Per la posizione B dobbiamo invece “alzare” il piedino D3.</p><p>Una importante precisazione da fare relativamente al relè di Rotilio Maker è che si tratta di un relè “bistabile”.
        La sua particolarità è quella di mantenere l’ultima posizione impostata senza la necessità di tensione costante applicata ai piedini di <code>set</code> e <code>reset</code>.
        Questo ci permette, ad esempio, di spegnere la CPU e mantenere l’impostazione del relè nella posizione desiderata. Non dobbiamo dimenticarci di questo dettaglio, vedremo perchè in seguito.</p><p>La funzione <code>relaisSet</code>, che porta il relè in posizione A dovrà quindi:</p><ol>
        <li>alzare il piedino D4 del Photon</li>
        <li>attendere il tempo necessario perchè il relè si sposti sulla posizione <code>set</code></li>
        <li>abbassare il piedino D4 del Photon</li>
    </ol><pre><code>void relaisSet(){
    digitalWrite(D7,HIGH);    // signal on Photon led that relais is SET (Position A)
    digitalWrite(D4,HIGH);    // set PIN D4 high
    delay(100);                  // waits for 100 milliseconds
    digitalWrite(D4,LOW);     // set PIN D4 low
}</code></pre><p>Similmente la funzione <code>relaisReset</code>, che porta il relè in posizione B dovrà:</p><ol>
        <li>alzare il piedino D3 del Photon</li>
        <li>attendere il tempo necessario perchè il relè si sposti sulla posizione <code>reset</code></li>
        <li>abbassare il piedino D3 del Photon</li>
    </ol><pre><code>void relaisReset(){
    digitalWrite(D7,LOW);     // signal on Photon led that relais is RESET (Position B)
    digitalWrite(D3,HIGH);    // set PIN D3 high
    delay(100);               // waits for 100 milliseconds
    digitalWrite(D3,LOW);     // set PIN D3 low
}</code></pre><p>Perchè il tutto funzioni correttamente occorre impostare, in fase di avviamento della CPU, le modalità di funzionamento dei PIN del Photon. Questo in Wiring(R) deve essere eseguito nella funzione predefinita <code>setup</code>.
        I pin D3 e D4 devono essere impostati in modo che fungano come <code>output</code>, visto che dovranno comandare il relè.</p><pre><code>void setup(){
    pinMode(D3,OUTPUT);
    pinMode(D4,OUTPUT);
}</code></pre><h4>Passiamo al sensore di temperatura</h4><p>In questo caso il sensore di temperatura è collegato ai PIN D0 e D1 del Photon, configurati in modalità I2C. Questa modalità permette di connettere più sensori sugli stessi PIN, aumentando così le possibilità di espansione del sistema.</p><p>Il sensore utilizzato su Rotilio Maker è un Si7020, prodotto da Silicon Labs, di cui possiamo reperire il data-sheet qui: <a href=""></a><a href="https://www.silabs.com/documents/public/data-sheets/Si7020-A20.pdf">https://www.silabs.com/documents/public/data-sheets/Si7020-A20.pdf</a></p><p>L’interrogazione di un dispositivo I2C si svolge nei seguenti passaggi:</p><ol>
        <li>Inizio la trasmissione su bus I2C all’indirizzo desiderato (ogni dispositivo ha un suo indirizzo impostato in fabbrica)</li>
        <li>Invio il comando da eseguire al dispositivo</li>
        <li>Termino la trasmissione e attendo che il dispositivo sia pronto a rispondere</li>
        <li>Leggo la risposta dal dispositivo, di solito uno o più bytes vengono letti</li>
    </ol><p>La risposta dal dispositivo solitamente ha bisogno di ulteriori passaggi per essere utilizzata:</p><ol>
        <li>compongo i byte ricevuti dal dispositivo in un valore intero</li>
        <li>converto il valore intero nella scala desiderata, in questo caso gradi centigradi</li>
    </ol><p>La parte di comunicazione con il bus I2C è pronta all’uso nella libreria “Wire” che andremo ad includere nel nostro codice.</p><p>Scriviamo quindi una funzione “generica” per dialogare con i nostri sensori I2C, potrà tornarci utile in altri casi.</p><p>La seguente funzione <code>readRawDataFromI2C</code> riceve in input due informazioni:</p><ul>
        <li>l’indirizzo del dispositivo I2C</li>
        <li>il comando da inviare al dispositivo</li>
    </ul><p>Restituirà in output un valore intero, che dovrà poi essere convertito nel valore desiderato.</p><pre><code>int readRawDataFromI2C(int address,int command){

    // send read command to sensor over I2C bus
    Wire.beginTransmission(address);
    Wire.write(command);
    Wire.endTransmission();

    // wait some time to let the sensor sense
    delay(20);

    // read three bytes from sensor
    Wire.requestFrom(address, 3);

    // compose a 16 bit value from 2 (msb and lsb) received bytes
    unsigned char msb = Wire.read();
    unsigned char lsb = Wire.read();
    unsigned char chk = Wire.read(); // checksum, not used
    int data = (((int) msb&lt;&lt;8) + (int) lsb);

    return data ;
}</code></pre><p>Utilizziamo adesso la funzione <code>readRawDataFromI2C</code> per leggere nello specifico la temperatura dal nostro sensore. Le costanti di conversione, l’indirizzo I2C e il comando sono tratti dal data-sheet del sensore.</p><pre><code>#define Si7020_ADDRESS              0x40
#define TEMPERATURE_READ_COMMAND    0xF3

double readTemperatureFromSensor(void){

    // read raw data from temperature sensor Si7020
    int data = readRawDataFromI2C(Si7020_ADDRESS, TEMPERATURE_READ_COMMAND);

    // convert raw data in celsius degrees
    double celsiusdegree = 175.72 * data / 65536 - 46.85;

    // round to first decimal
    double roundedcelsiusdegree = round(celsiusdegree*10)/10 ;

    return roundedcelsiusdegree ;
}</code></pre><p>Non dimentichiamoci che la libreria “Wire” deve essere inizializzata all’avviamento della CPU, quindi modifichiamo la funzione <code>setup</code> come segue:</p><pre><code>void setup(){
    pinMode(D3,OUTPUT);
    pinMode(D4,OUTPUT);
    Wire.begin();
}</code></pre><p>A questo punto il firmware potrebbe essere pronto, se volete potete ottenere il codice completo di quanto fatto fino adesso, cliccando qui: <a href="https://github.com/techmakers/rotiliothermo/blob/master/firmware/rotiliothermo_step01.ino">rotiliothermo_step01.ino</a>.</p><p>Prima di procedere con il caricamento di questo sorgente sul Photon di Rotilio Maker, dobbiamo però risolvere un problema, anzi due: </p><ul>
        <li>non possiamo variare la temperatura impostata su un valore diverso dai 21 °C</li>
        <li>non possiamo mettere il riscaldamento in modalità “spento”, a meno di non modificare le prime righe con valori di default per <code>heaterOn</code> e <code>Ts</code>.</li>
    </ul><p>Inoltre non sappiamo se il nostro termostato ha inviato alla caldaia il comando di avviamento o meno.</p><p>Ma qui ci viene incontro Particle.io con le API di comunicazione con il Photon attraverso il cloud.</p><p>Le API di Particle.io, tra le altre cose, permettono di accedere a dati presenti nel dispositivo (variabili) e di inviare comandi al dispositivo (funzioni).</p><p>Potremo rendere leggibili dal Web le variabili <code>T</code>, <code>Ts</code>, <code>heaterOn</code>, <code>relaisAorB</code> e chiamare delle funzioni che impostano <code>heaterOn</code> e <code>Ts</code>.</p><h3 id="rotilio-thermo-primi-passi-come-rendere-leggibile-una-variabile">Come rendere leggibile una variabile.</h3><p>Le variabili su pubblicano verso il WEB con la funzione <code>Particle.variable("&lt;nome_per_il_web&gt;",variabile)</code>.</p><p>Tutte le informazioni relativamente alla pubblicazione di variabili nel Cloud sono disponibili sul sito Particle.io nella sezione documentazione: <a href=""></a><a href="https://docs.particle.io/reference/firmware/photon/#particle-variable-">https://docs.particle.io/reference/firmware/photon/#particle-variable-</a></p><p>Ecco un esempio applicato al nostro firmware.</p><pre><code>Particle.variable("heateron",heaterOn);</code></pre><p>Questa riga di codice va aggiunta nella funzione <code>setup</code>, ottenendo quindi quanto segue:</p><pre><code>void setup(){

    Particle.variable("heateron",heaterOn);

    pinMode(D3,OUTPUT);
    pinMode(D4,OUTPUT);
    Wire.begin();
}</code></pre><p>Possiamo ripetere la cosa per le altre variabili, ottenendo quindi la funzione <code>setup</code> come segue:</p><pre><code>void setup(){

    Particle.variable("heateron",heaterOn);
    Particle.variable("temperature",T);
    Particle.variable("tempsetpoint",Ts);
    Particle.variable("relaisaorb",relaisAorB);

    pinMode(D3,OUTPUT);
    pinMode(D4,OUTPUT);
    Wire.begin();
}</code></pre><p>Non dimentichiamoci che:</p><ul>
        <li>i nomi delle variabili Cloud possono essere lunghi al massimo 12 caratteri</li>
        <li>possiamo registrare al massimo 20 variabili Cloud</li>
    </ul><p>Da questo momento, caricando il firmware sul Photon con questa ultima versione della funzione <code>setup</code> sarà possibile leggere dal WEB le quattro variabili.</p><p>Vediamo un esempio:</p><pre><code>https://api.particle.io/v1/devices/420026001147343339383037/heateron?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c</code></pre><p>Attenzione, se provate ad aprire questo indirizzo senza prima aver caricato il firmware sul Photon, otterrete un messaggio di risposta come questo: <code>{"ok":false,"error":"Unknown Variable: false"}</code>.</p><p>L’indirizzo appena menzionato è una composizione delle seguenti parti:</p><ul>
        <li>url del cloud di Particle.io: <code>https://api.particle.io</code></li>
        <li>versione delle API: <code>v1</code></li>
        <li>funzione di accesso ai dispositivi: <code>devices</code></li>
        <li>id del dispositivo: <code>420026001147343339383037</code></li>
        <li>nome della variabile web: <code>heateron</code></li>
        <li>access_token, ovvero, la parola d’ordine, o password che dir si voglia, senza la quale non si può accedere al dispositivo: <code>89d67f062abf6d45aa95f176642479d7caf5ca3c</code> (quindi tenetela per voi)</li>
    </ul><h3 id="rotilio-thermo-primi-passi-caricare-il-firmware-sul-vostro-rotilio-maker">Caricare il firmware sul vostro Rotilio Maker</h3><p>Si, è giunto il momento di provare davvero a comunicare con il vostro Rotilio Maker e i suoi sensori, questo grazie al firmware che caricheremo sul Photon grazie al cloud di Particle.io.</p><p>L’operazione la prima volta richiede un po’ di passaggi, ma successivamente si rivelerà un lavoro di routine molto veloce e semplice.</p><p>Scomponiamo l’attività nei seguenti passaggi:</p><ol>
        <li>connessione di Rotilio Maker alla rete WiFi</li>
        <li>accesso al cloud di Particle.io</li>
        <li>Caricamento del firmware nel cloud di Particle.ioì</li>
        <li>Invio del firmware al Rotilio Maker</li>
    </ol><h4>Connessione di Rotilio Maker alla rete WiFi</h4><p>Questa attività è più semplice se eseguita attraverso l’apposita APP Mobile fornita gratuitamente da Particle.io, potete scegliere tra queste piattaforme:</p><ul>
        <li><a href="https://play.google.com/store/apps/details?id=io.particle.android.app">Android</a></li>
        <li><a href="https://itunes.apple.com/us/app/particle-build-photon-electron/id991459054?ls=1&amp;mt=8">iOS</a></li>
        <li><a href="https://www.microsoft.com/en-us/store/p/particle/9nblggh4p55n">Windows</a></li>
    </ul><p>Riassumiamo di seguito i passaggi, per poi rimandarvi alla apposita pagina di supporto di Particle.io.</p><ol>
        <li>Alimentare il Rotilio Maker (potete usare un cavetto USB collegato al vostro computer e al Photon del Rotilio Maker)</li>
        <li>Se il LED del Photon esegue una serie di lampeggi per poi diventare azzurro evanescente, allora vuol dire che il collegamento alla WiFi era già stato eseguito, altrimenti dovrebbe lampeggiare di un colore blu scuro, in attesa di ricevere le credenziali della WiFi.</li>
        <li>Mediante l’App Mobile di Particle.io, seguendo i passaggi indicati a questo indirizzo <a href=""></a><a href="https://docs.particle.io/guide/getting-started/start/photon/#step-1-power-on-your-device">https://docs.particle.io/guide/getting-started/start/photon/#step-1-power-on-your-device</a>, inserite le credenziali e verificate che il Photon si connetta alla vostra rete WiFi direttamente.</li>
    </ol><p>Se doveste incontrare delle difficoltà in questa fase, una risorsa utile è la pagina delle FAQ di Particle.io: <a href=""></a><a href="https://docs.particle.io/faq/particle-devices/led-troubleshooting/photon/">https://docs.particle.io/faq/particle-devices/led-troubleshooting/photon/</a></p><p>IMPORTANTE: Durante la fase di setup delle credenziali WiFi avviene anche la registrazione sul cloud di Particle.io. Le credenziali tenetele sotto mano, perchè servono anche al passaggio successivo, in modo da entrare sul cloud con le stesse utilizzate per attivare il Photon, e trovarlo quindi nella lista dei dispositivi associati all’account.</p><h3 id="rotilio-thermo-primi-passi-accesso-al-cloud-di-particleio">Accesso al cloud di Particle.io</h3><p>Come detto il cloud di Particle.io fornisce una serie di servizi tra cui:</p><ul>
        <li>layer di comunicazione (e relative API) con i dispositivi</li>
    </ul><p>ma anche:</p><ul>
        <li>ambiente di sviluppo integrato (IDE) <a href=""></a><a href="https://build.particle.io">https://build.particle.io</a></li>
        <li>console di gestione dei dispositivi <a href=""></a><a href="https://console.particle.io">https://console.particle.io</a></li>
        <li>documentazione delle API (cloud e firmware) <a href=""></a><a href="https://docs.particle.io">https://docs.particle.io</a></li>
    </ul><p>Al momento ci interessa l’ambiente di sviluppo integrato, quindi apriamo il relativo link e inseriamo, se è la prima volta che lo facciamo, le credenziali di accesso, le stesse utilizzate per attivare il Photon di Rotilio Maker.</p><p>Ecco cosa dovreste vedere cliccando qui con il vostro browser: <a href=""></a><a href="https://build.particle.io">https://build.particle.io</a></p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/build_particle_io_login.png" alt="Particle.IO IDE Login"></p><p>Appena inserite le proprie credenziali si presenta la schermata principale di Particle.io</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_main.png" alt="Particle.IO Main screen"></p><p>Per accedere quindi all’IDE cliccate in alto a DX alla voce IDE appunto, verrete indirizzati ad una pagina come la seguente.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide.png" alt="Particle.IO IDE screen"></p><p>La schermata è divisa in due parti principali, a sinistra abbiamo la toolbar con le icone. Ogni click su un icona predispone la colonna subito a destra della toolbar con i contenuti e le azioni contestualizzate.
        Nella parte di destra troviamo sempre l’editor del codice che potremo inviare al Photon.</p><p>Per poter caricare il firwmare sul Photon del Rotilio Maker dobbiamo:</p><ol>
        <li>copiare il firmware negli appunti, prelevandolo da questo indirizzo: <a href="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/firmware/rotiliothermo_step02.ino">rotiliothermo_step02.ino</a></li>
        <li>selezionare il dispositivo target (quello a cui invieremo il firmware)</li>
        <li>incollare il contenuto degli appunti nella parte destra della schermata</li>
        <li>dare un nome al firmware, es: rotiliothermo_step02</li>
        <li>salvare e compilare il firmware (in questa fase il codice viene caricato sul cloud)</li>
        <li>inviare il firmware compilato al Photon (che deve essere connesso ad Internet perchè il trasferimento avviene tra il cloud e il Photon)</li>
    </ol><h4>Copiare il firmware negli appunti</h4><p>Potete prelevare i singoli pezzi di codice da questo tutorial e incollarli nella parte destra della schermata, oppure potete andare a questo indirizzo su GitHub: <a href="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/firmware/rotiliothermo_step02.ino">rotiliothermo_step02.ino</a> come da schermata seguente, selezionare tutto e incollarlo negli appunti.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/github_rotiliothermo_code.png" alt="GitHub code screen"></p><h4>Selezionare il dispositivo target</h4><p>Tornate nella schermata dell’IDE di Particle e cliccate sull’icona indicata con “1.a” e poi selezionate il dispositivo cliccando sulla relativa stellina come indicato con “1.b”, infine cliccare sull’icona per tornare alla gestione applicazioni come indicato con “1.c”.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_device_selection.png" alt="Particle.io IDE select device example"></p><h4>Incollare il contenuto degli appunti</h4><p>Il codice del firmware va incollato nella parte destra dello schermo come nell’esempio seguente.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_with_code.png" alt="Particle.IO IDE screen with code"></p><p>Prima di incollare abbiate cura di pulire la parte di destra del codice in modo che sia completamente sgombra e pronta per accogliere il codice che avete copiato negli appunti al punto 1.</p><h4>Dare un nome al firmware</h4><p>Digitare il nome dell’applicazione come indicato in figura seguente.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_application_name.png" alt="Particle.IO IDE screen application name"></p><h4>Salvare e compilare il firmware</h4><p>Cliccare sull’icona di salvataggio (Save), poi su quella di compilazione (Verify) e se non vengono riportati errori procedere con l’invio del firmware al dispositivo (Flash), come nelle figure seguenti.</p><p>Save</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_save.png" alt="Particle.IO IDE screen application save"></p><p>Verify</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_verify.png" alt="Particle.IO IDE screen application verify"></p><p>Flash</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_flash.png" alt="Particle.IO IDE screen application flash"></p><p>In questa fase dovreste veder lampeggiare color magenta il LED del Photon, attendete fino quando il processo non si conclude, con la sequenza di colore verde lampegginte, azzurro lampeggiante, azzurro evanescente.</p><p>Ogni volta che andremo a modificare il firmware, sarà necessario ripetere l’ultimo punto (Flash) per inviare l’aggiornamento al nostro Photon.</p><h3 id="rotilio-thermo-primi-passi-test-delle-variabili">Test delle variabili</h3><p>Appena ricevuto l’aggiornamento di firmware il Photon si riavvia e inizia ad eseguire il nuovo codice.</p><p>Prima di procedere con le altre attività la cosa migliore è verificare che le variabili siano realmente leggibili.</p><p>Come detto, la cosa è facilmente attuabile utilizzando un browser WEB inserendo nella barra degli indirizzi la stringa che corrisponde all’url del dispositivo e della variabile da testare.</p><p>Per comporre questa stringa ci occorrono tre informazioni specifiche:</p><ul>
        <li>la nostra access_token</li>
        <li>il device ID</li>
        <li>il nome della variabile</li>
    </ul><h4>Reperire l’access_token</h4><p>L’access_token si può ottenere attraverso l’IDE di particle, cliccando sull’icona “Settings” nella schermata in basso a sinistra.</p><p>Si aprirà un pannello che mostra alcuni pulsanti e una casella di testo contenente l’access_token.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_settings_access_token.png" alt="Particle.IO IDE screen access_token"></p><p>Copiate e incollate l’access_token in un editor di testo.</p><h4>Reperire il device ID</h4><p>Il device ID è una stringa di caratteri esadecimali che contraddistingue ogni device Particle.io in maniera univoca in tutto il mondo.
        Ogni device viene serializzato con una stringa univoca in fabbrica, questa stringa non si può cambiare.
        La coppia “deviceID &amp; access_token” sono l’equivalente di nome utente e password. Tenerli al sicuro garantisce che nessun altro possa interagire con il nostro device.</p><p>Anche il device ID è reperibile attraverso l’IDE di Particle.io, come in figura, cliccare sull’icona dei device (il mirino), si aprirà un pannello con l’elenco dei device, cliccare quindi sul freccino a destra di ogni device per aprire i dettagli del device desiderato.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/particle_io_ide_device_id.png" alt="Particle.IO IDE screen access_token"></p><p>Se avete diversi device, utilizzate il tasto SIGNAL per verificare che il device selezionato sia quello giusto. Se è quello giusto, al click del tasto SIGNAL il LED del device inizierà a lampeggiare con i colori di un arcobaleno.</p><p>Copiate e incollate il device ID in un editor di testo.</p><h4>Eseguiamo il test di lettura delle variabili</h4><p>Adesso che abbiamo tutti gli elementi possiamo comporre, nel nostro editor di testo preferito, l’url che poi copieremo e incolleremo nella barra degli indirizzi del browser.</p><p>Se vogliamo leggere la temperatura rilevata dal sensore di Rotilio Maker, dovremo comporre un URL come il seguente:</p><pre><code>https://api.particle.io/v1/devices/420026001147343339383037/temperature?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c</code></pre><p>Abbiate cura di sostituire: </p><ul>
        <li>420026001147343339383037 con il vostro device ID</li>
        <li>89d67f062abf6d45aa95f176642479d7caf5ca3c con la vostra access_token</li>
    </ul><p>Copiando e incollando la stringa così composta nel vostro browser dovreste ottenere una risposta come la seguente:</p><pre><code>{
    "cmd": "VarReturn",
    "name": "status",
    "result": 21.6,
    "coreInfo": {
        "last_app": "",
        "last_heard": "2017-09-16T12:02:34.553Z",
        "connected": true,
        "last_handshake_at": "2017-09-16T11:37:25.199Z",
        "deviceID": "420026001147343339383037",
        "product_id": 6
    }
}</code></pre><p>Quello che otteniamo in risposta è una stringa che rappresenta un oggetto javascript, in formato JSON.</p><p>L’oggetto ha diverse proprietà, tra cui <code>result</code>, in questo esempio pari a 21.6, che sono i gradi centigradi di temperatura presenti nella stanza in cui si trova Rotilio Maker.</p><p>Provate a sostituire <code>temperature</code> con altre variabili come <code>tempsetup</code> e così via, per vedere che valori vengono resituiti dal Rotilio Maker.</p><h4>Cosa può andare storto</h4><p>Se non ottenete la giusta risposta dal vostro Rotilio Maker, vi consigliamo di controllare:</p><ul>
        <li>la correttezza dell’access_token e del device ID</li>
        <li>che il Rotilio Maker sia connesso correttamente al Cloud, controllate quindi il colore del LED, deve essere azzurro evanescente, come un respiro.</li>
        <li>che il vostro computer sia connesso ad Internet</li>
        <li>le impostazioni di eventuali firewall, che potrebbero bloccare alcune porte in uscita utilizzate dal Photon per comunicare con il Cloud di Particle.io (questo solitamente se state provando il tutto connessi ad una rete aziendale ben protetta)</li>
    </ul><p>Ecco una lista di porte TCP che vanno aperte in uscita, verso l’indirizzo di rete corrispondente a: <code>api.particle.io</code></p><pre><code>5683
16384
16385
16386</code></pre><h3 id="rotilio-thermo-primi-passi-inviare-comandi-al-dispositivo">Inviare comandi al dispositivo</h3><p>Per poter impostare il modo di funzionamento del nostro dispositivo occorre prevedere la possibilità di inviargli le impostazioni di accensione o meno del riscaldamento e la temperatura desiderata.</p><p>Questo si ottiene creando due funzioni distinte, con lo scopo di modificare il valore delle variabili <code>heaterOn</code> e <code>Ts</code>.</p><p>Iniziamo con scrivere le due apposite funzioni, che riceveranno in input il nuovo valore da impostare nelle rispettive variabili.</p><p>La funzione per impostare l’accensione del riscaldamento</p><pre><code>int setHeaterMode(String _onoff){

    // cast from String to integer
    int onoff = _onoff.toInt();

    // input value check (returns an error code: 1 or 2)
    if (onoff &gt; 1) return 1 ;
    if (onoff &lt; 0) return 2 ;

    // set new value for heaterOn variable
    heaterOn = onoff ;

    // return 0 for OK
    return 0 ;
}</code></pre><p>e quella per impostare la temperatura desiderata</p><pre><code>int setTempSetpoint(String _t){

    // cast from String to integer
    int t = _t.toInt() ;

    // input value check
    if (t &lt; 18) return 1 ;
    if (t &gt; 28) return 2 ;

    // set new value for Ts variable
    Ts = t ;

    // returns 0 for OK
    return 0 ;
}</code></pre><p>Il fatto di utilizzare una funzione per impostare il valore di una variabile ci consente di eseguire opportuni controlli di validità del dato in input prima di modificarne effettivamente il valore.</p><p>La funzione può restituire un valore intero, per convenzione, zero indica nessun errore, altri valori, diversi da zero indicano un errore.</p><p>Nel nostro caso, per entrambe le funzioni, un valore 1 restituito in uscita indica che il valore ricevuto in input è inferiore al minimo valore ammesso.
        Un valore 2 indica invece che il valore ricevuto in input è superiore al massimo valore ammesso.</p><p>In questo modo, il dispositivo si autoprotegge, accettando 0 e 1 per la variabile heaterOn e valori compresi tra 18 e 28 °C per la variabile Ts.</p><p>Le due funzioni vanno aggiunte in fondo al nostro codice, ma perchè siano richiamabili dal cloud, occorre ancora un ultimo passaggio.</p><p>Dobbiamo “pubblicare” le funzioni, come abbiamo fatto per le variabili, utilizzando le API di Particle.io </p><pre><code>Particle.function("funcKey", funcName);</code></pre><p>come indicato a questo indirizzo: <a href=""></a><a href="https://docs.particle.io/reference/firmware/photon/#particle-function-">https://docs.particle.io/reference/firmware/photon/#particle-function-</a></p><p>Le righe di codice che pubblicano sul Cloud di Particle.io le nostre due funzioni vanno inserite nella funzione setup, ottenendo così quanto segue:</p><pre><code>void setup(){

    Particle.variable("heateron",heaterOn);
    Particle.variable("temperature",T);
    Particle.variable("tempsetpoint",Ts);
    Particle.variable("relaisaorb",relaisAorB);

    Particle.function("setheater",setHeaterMode) ;
    Particle.function("settemp",setTempSetpoint) ;

    pinMode(D3,OUTPUT);
    pinMode(D4,OUTPUT);

    Wire.begin();

}</code></pre><p>Trovate il codice completo del firmware a questo URL: <a href="https://github.com/techmakers/rotiliothermo/blob/master/firmware/rotiliothermo_step03.ino">rotiliothermo_step03.ino</a>.</p><p>Adesso possiamo inviare (Flash) il nuovo firmware al Photon e provare a richiamare le funzioni dal WEB.</p><h4>Test di chiamata delle funzioni</h4><p>Le nostre funzioni sono state pubblicate con i nomi: <code>setheater</code> e <code>settemp</code>.</p><p>La chiamata via WEB deve avvenire con il metodo http POST. Il browser WEB permette, mediante inserimento di URL nella barra indirizzi, solo richieste con il metodo http GET.</p><p>Ecco come dovrebbe essere composta la POST.</p><pre><code>POST /v1/devices/{DEVICE_ID}/{FUNCTION}</code></pre><p>Per questo motivo, nel caso delle funzioni, occorre utilizzare uno strumento diverso dal browser.</p><p>Il più semplice e largamente disponibile è il comando <code>curl</code>.</p><p>Potete scoprire se è disponibile nel vostro sistema aprendo una finestra di terminale, o prompt dei comandi, e digitare appunto <code>curl --help</code>.</p><p>Se presente verrà listata una serie di opzioni disponibili per il comando curl.</p><p>Se non presente occorre installarlo, a seconda della piattaforma Linux, Mac o Windows del vostro PC è necessaria una differente, ma comunque semplice, procedura.</p><pre><code>curl https://api.particle.io/v1/devices/420026001147343339383037/settemp \
     -d access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c \
     -d "args=27"</code></pre><p>eseguendo il comando otteniamo, se tutto corretto, una risposta come questa:</p><pre><code>{"id":"420026001147343339383037","last_app":"","connected":true,"return_value":0}</code></pre><p>Il valore <code>return_value</code> pari a 0 ci indica che il comando è stato recepito senza errori.</p><p>Se proviamo ad inviare una temperatura desiderata di 29 °C con il seguente comando:</p><pre><code>curl https://api.particle.io/v1/devices/420026001147343339383037/settemp \
     -d access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c \
     -d "args=29"</code></pre><p>otteniamo una risposta come questa:</p><pre><code>{"id":"420026001147343339383037","last_app":"","connected":true,"return_value":2}</code></pre><p>Dove <code>return_value</code> è pari a 2, ovvero, valore superiore al massimo consentito di 28 °C.</p><h2 id="rotilio-thermo-testiamo-il-nostro-termostato-opensource">Testiamo il nostro termostato opensource</h2><p>A questo punto del lavoro abbiamo inserito nel firmware tutti gli elementi necessari a controllare il riscaldamento mediante il nostro Rotilio Maker.</p><p>Il test è abbastanza semplice, partendo dal presupposto che:</p><ul>
        <li>se la temperatura rilevata è inferiore a quella desiderata, il relè deve spostarsi in posizione A, altrimenti deve spostarsi in B</li>
    </ul><p>possiamo quindi, per verificare se il relè si sposta in posizione A, impostare una temperatura desiderata superiore alla temperatura rilevata, esempio:</p><ul>
        <li>se la temperatura rilevata è di 25 gradi, potremo settare quella desiderata a 27 e capire se il relè si sposta da A a B.</li>
    </ul><p>L’attività di test si svolge su due fronti:</p><ul>
        <li>software: inviamo comandi e leggiamo lo stato del dispositivo</li>
        <li>hardware: verifichiamo se il relè è nella posizione desiderata</li>
    </ul><p>Prima di procedere assicurarsi di non avere nessun collegamento elettrico sul morsetto del relè. Il test deve essere fatto “a vuoto”.</p><h3 id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-sequenza-di-test-software">Sequenza di test software</h3><p>Leggiamo la temperatura rilevata</p><pre><code>curl https://api.particle.io/v1/devices/36001b001551353531343431/temperature?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c</code></pre><p>Interpretiamo la risposta</p><pre><code>{"cmd":"VarReturn","name":"temperature","result":24.3,"coreInfo":{"last_app":"","last_heard":"2017-09-22T14:02:37.021Z","connected":true,"last_handshake_at":"2017-09-22T12:04:59.090Z","deviceID":"36001b001551353531343431","product_id":6}}</code></pre><p>In questo caso leggiamo 24.3 °C</p><p>Impostiamo quindi una temperatura desiderata di 26 °C</p><pre><code>curl https://api.particle.io/v1/devices/36001b001551353531343431/settemp \
     -d access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c \
     -d "args=27"</code></pre><p>Verifichiamo la risposta</p><pre><code>{"id":"36001b001551353531343431","last_app":"","connected":true,"return_value":0}</code></pre><p>In questo caso <code>return_value</code> è 0 quindi OK</p><p>Leggiamo se effettivamente Rotilio Maker ha recepito la temperatura desiserata</p><pre><code>curl https://api.particle.io/v1/devices/36001b001551353531343431/tempsetpoint?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c</code></pre><p>Verifichiamo la risposta</p><pre><code>{"cmd":"VarReturn","name":"tempsetpoint","result":27,"coreInfo":{"last_app":"","last_heard":"2017-09-22T14:06:57.132Z","connected":true,"last_handshake_at":"2017-09-22T12:04:59.090Z","deviceID":"36001b001551353531343431","product_id":6}}</code></pre><p>In questo caso <code>result</code> è 27, come ci aspettavamo.</p><p>Controlliamo se il relais è stato spostato in posizione A</p><pre><code>curl https://api.particle.io/v1/devices/36001b001551353531343431/relaisAorB?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c</code></pre><p>Verifichiamo la risposta</p><pre><code>{"cmd":"VarReturn","name":"relaisAorB","result":0,"coreInfo":{"last_app":"","last_heard":"2017-09-22T14:08:47.371Z","connected":true,"last_handshake_at":"2017-09-22T12:04:59.090Z","deviceID":"36001b001551353531343431","product_id":6}}</code></pre><p>In questo caso è ancora in posizione B, essendo <code>result</code> pari a 0.</p><p>E’ normale, dato che il firmware opera ogni 30 secondi, quindi occorre attendere al massimo 30 secondi e riprovare la chiamata</p><pre><code>curl https://api.particle.io/v1/devices/36001b001551353531343431/relaisAorB?access_token=89d67f062abf6d45aa95f176642479d7caf5ca3c</code></pre><p>Verifichiamo nuovamente la risposta:</p><pre><code>{"cmd":"VarReturn","name":"relaisAorB","result":1,"coreInfo":{"last_app":"","last_heard":"2017-09-22T14:11:17.308Z","connected":true,"last_handshake_at":"2017-09-22T12:04:59.090Z","deviceID":"36001b001551353531343431","product_id":6}}</code></pre><p>Adesso <code>result</code> è pari a 1, quindi il relè è stato spostato in posizione A.</p><p>Dovremmo aver sentito anche il “click” del relè che cambia posizione.</p><h3 id="rotilio-thermo-testiamo-il-nostro-termostato-opensource-test-hardware">Test hardware</h3><p>Il test hardware consiste nel verificare che le posizioni del relè corrispondano ai relativi contatti sul morsetto del relè.</p><p>La figura seguente illustra la posizione dei contatti e relativa chiusura.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/RotilioThermoPictures.002.png" alt="Rotilio Maker Explained Relais"></p><p>Se usiamo un tester per verificare la continuità tra il “Common” e A, dovremo trovare continuità quando il relè è in posizione A e viceversa.</p><p>La continuità si misura sempre tra “Common” e A o tra “Common” e B, mai tra A e B.</p><h2 id="rotilio-thermo-collegamento-del-sistema-di-riscaldamento">Collegamento del sistema di riscaldamento</h2><p>Come detto inizialmente, il relè di Rotilio Maker dovrà essere collegato ai due fili che normalmente vanno dalla caldaia al termostato.</p><p>Le due figure seguenti illustrano i possibili collegamenti, che dovranno essere applicati al proprio caso.</p><p>Se la caldaia si aspetta il contatto chiuso per avviarsi, dovremo utilizzare il modo A, altrimenti il modo B.</p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/RotilioThermoPictures.003.png" alt="Heating system connection - Mode A"></p><p><img src="https://raw.githubusercontent.com/techmakers/rotiliothermo/master/images/RotilioThermoPictures.004.png" alt="Heating system connection - Mode B"></p><h2 id="rotilio-thermo-cosa-abbiamo-imparato">Cosa abbiamo imparato</h2><p>Le nozioni fin qui acquisite appartengono al campo del software, dell’hardware e delle comunicazioni (cloud).</p><p>Per la parte software abbiamo imparato a scrivere un piccolo programma che, dato un determinato input, prende delle decisioni e fornisce un output.</p><p>Abbastanza tradizionale.</p><p>Il tutto però diventa interessante perchè gli input provengono da internet e dall’ambiente circonstante, dalle cose, ecco l’Internet delle Cose.</p><p>Abbiamo imparato ad azionare qualcosa, che è il nostro output, ovvero la posizione del relè e conseguentemente il funzionamento della caldaia.</p><h2 id="rotilio-thermo-prossimi-passi">Prossimi passi</h2><p>Ci sono cose che si “possono” fare, ma altre che si “devono” fare.</p><p>Quello che “possiamo” fare ad esempio potrebbe essere di pubblicare lo stato del sistema ogni volta che c’è una variazione.</p><p>Ad esempio potremmo inviare sul cloud un segnale ogni volta che il relè passa da A a B e viceversa, informando così un APP o un utente.</p><p>Quello che “dobbiamo” fare sono altre cose molto importanti.</p><p>La prima cosa da fare è ottimizzare il sistema di regolazione.</p><p>Facciamo un ipotesi:</p><ul>
        <li>temperatura desiderata: 23.0 °C</li>
        <li>temperatura rilevata: 23.0 °C</li>
    </ul><p>In questo caso, la temperatura rilevata è pari a quella desiderata, il relè sarà quindi in posizione B.</p><p>La risoluzione della lettura del nostro sensore è di 0.1 °C.</p><p>Se al loop successivo (30 secondi dopo) la temperatura è scesa di 0.1°C il nostro sensore la rileva e il relè passa in posizione “A” per iniziare a scaldare.</p><p>Se dopo altri 30 secondi, altro loop, la temperatura risale di 0.1°C e torna quindi a 23.0°C ecco che il nostro relè torna in posizine B.</p><p>Se la temperatura rilevata continua ad oscillare di 0.1°C rischiamo di accendere e spegnere il riscaldamento ogni 30 secondi, rischiando di:</p><ul>
        <li>danneggiare la calderina</li>
        <li>sprecare energia, quindi gas</li>
    </ul><p>Occorre trovare una soluzione al problema, ma facciamo una piccola riflessione.</p><p>Il sistema che stiamo costruendo è un sistema a retroazione.</p><p>Il feedback è dato dalla temperatura rilevata. L’errore è la differenza tra temperatura desiderata e temperatura rilevata.</p><p>Se l’errore è &gt; 0 allora chiudiamo il circuito di controllo della calderina, altrimenti lo apriamo.</p><p>La nostra regolazione è a due stati discreti, senza valori intermedi.
        Per questo, la teoria della regolazione, tanto ben illustrata in questo interessante documento <a href=""></a><a href="http://www.unife.it/ing/lm.meccanica/insegnamenti/dinamica-controllo-diagnosi-di-sistemi-b/materiale-didattico/Controllori_PID.pdf">http://www.unife.it/ing/lm.meccanica/insegnamenti/dinamica-controllo-diagnosi-di-sistemi-b/materiale-didattico/Controllori_PID.pdf</a>, non è applicabile.</p><p>Quello che però possiamo fare però sono due cose:</p><ol>
        <li><p>stabilizzare la lettura della temperatura, in modo da evitare oscillazioni non volute, dovute a: instabilità del sensore, apertura di finestre vicino al sensore, passaggi di cose molto calde vicino al sensore e così via.</p>
        </li>
        <li><p>proteggere il ciclo di accensione e spegnimento introducendo dei ritardi in modo da impedire l’accensione subito dopo uno spegnimento.</p>
        </li>
    </ol><h3 id="rotilio-thermo-prossimi-passi-stabilizzare-la-lettura-della-temperatura">Stabilizzare la lettura della temperatura</h3><p>La cosa più semplice per raggiungere questo obiettivo è quella di calcolare la temperatura media di un periodo di tempo, così da rilevare reali variazioni significative della temperatura.</p><p>Un buon sistema è quello di tenere in memoria le ultime N letture di temeperatura e usare la media di queste letture come valore in ingresso alla funzione di regolazione.</p><p>Occorre quindi:</p><ol>
        <li>predisporre un array di <code>double</code> dove memorizzare le ultime N letture</li>
        <li>modificare la funzione di lettura temperatura che: <ol>
            <li>scali (shiftare) le temperature indietro di una posizione ad ogni nuova lettura</li>
            <li>memorizzi la nuova nell’ultima posizione</li>
            <li>calcoli la media e la memorizzi nella variabile <code>T</code></li>
        </ol>
        </li>
    </ol><p>Ipotizzando di eseguire la media su 10 letture, con un loop di 30 secondi, il valore medio della temperatura corrisponderà alla media degli ultimi 300 secondi, ovvero cinque minuti.</p><p>Con un po’ di sperimentazione si arriverà a capire se 10 letture sono troppe (sistema troppo lento) o troppo poche (sistema troppo sensibile).</p><p>Dipende molto dalla velocità con cui l’ambiente si scalda o si raffredda.</p><p>Vediamo di seguito un implementazione possibile.</p><p>Primo punto, predisponiamo l’array dove andremo a memorizzare le ultime 10 temperature</p><pre><code>#define READINGS_COUNT 10        // here we can setup the number of readings we want to store
#define BLANK_VALUE -9999        // this will be used to fill the temperature history array with a known initial value
double temperatureHistory[READINGS_COUNT] ; // here we will store the temperature history</code></pre><p>Predisponiamo anche la funzione che inizializza il nostro array</p><pre><code>// this will be called in the setup or every time we want to clean the temperature history reading
void temperatureHistoryInit(){
    for (int i = 0; i &lt; arraySize(temperatureHistory); i++) {
          temperatureHistory[i] = BLANK_VALUE ;
    }
}</code></pre><p>Questa è la funzione che memorizza la temperatura nell’array.</p><p>Alla prima lettura di, ad esempio 20°C, il nostro array sarà una cosa del genere:</p><pre><code>20,20,20,20,20,20,20,20,20,20</code></pre><p>Alla seconda lettura di, ad esempio 20.5 °C, il nostro array sarà una cosa del genere:</p><pre><code>20,20,20,20,20,20,20,20,20,20.5</code></pre><p>Alla terza lettura, di 20.6, avremo quindi:</p><pre><code>20,20,20,20,20,20,20,20,20.5,20.6</code></pre><pre><code>void temperatureHistoryStore(double t){

    int lastIndex = READINGS_COUNT - 1 ;

    // the first time this function will run, we fill the array with the new t value
    for (int i = 0; i &lt;= lastIndex; i++) {
          if (temperatureHistory[i] == BLANK_VALUE) temperatureHistory[i] = t ;
    }

    // shift all the elements to the left, loosing the first one each time
    for (int i = 0; i &lt; lastIndex; i++) {
          temperatureHistory[i] = temperatureHistory[i+1] ;
    }

    // store new temperature in the last array position
    temperatureHistory[lastIndex] = t ;

}</code></pre><p>La funzione che calcola la media delle 10 temperature</p><pre><code>double temperatureHistoryCalcAverage(){

    // sum all values in the array
    double tempSum = 0 ;
    for (int i = 0; i &lt; READINGS_COUNT; i++) {
        double t = temperatureHistory[i] ;
          tempSum = tempSum + temperatureHistory[i] ;
    }

    // calulating average temperature
    double average = tempSum / READINGS_COUNT ;

    // returning rounded value of average
    return round(average*10)/10.0 ;

}</code></pre><p>infine occorre modificare la procedura di setup aggiungendo la chiamata alla funzione <code>temperatureHistoryInit</code>, come segue:</p><pre><code>void setup(){

    temperatureHistoryInit() ;

    ...

}</code></pre><p>per concludere, modifichiamo la funzione <code>loop</code> così da utilizzare le precedenti funzioni:</p><pre><code>void loop(){

    double lastT = readTemperatureFromSensor() ;  // acquire actual temperature
    temperatureHistoryStore(lastT) ;              // store last temperature reading
    T = temperatureHistoryCalcAverage() ;         // calc temperature average

   [...]</code></pre><p>Potete scaricare il codice modificato con la stabilizzazione della lettura della temperatura, cliccando qui: <a href="https://github.com/techmakers/rotiliothermo/blob/master/firmware/rotiliothermo_step04.ino">rotiliothermo_step04.ino</a>.</p><h3 id="rotilio-thermo-prossimi-passi-proteggiamo-il-ciclo-di-accensione-e-spegnimento">Proteggiamo il ciclo di accensione e spegnimento</h3><p>Per evitare accensioni e spegnimenti troppo frequenti, possiamo introdurre una variabile che tenga conto dell’ultima volta che abbiamo fermato la caldaia, chiamando la funzione <code>resetRelais</code>.</p><p>In questo caso può tornare utile la funzione <code>Time.now()</code> che restituisce un intero che rappresenta il numero di secondi trascorsi dall’avviamento dall’ 1/1/70.</p><p>Ad ogni chiamata della funzione <code>resetRelais</code> possiamo memorizzare questo numero in una variabile, così, nel momento in cui decideremo di accendere chiamando la funzione <code>setRelais</code> possiamo decidere di proseguire o meno nell’invio del comando al relè, la volta successiva se non sono trascorsi almeno N secondi.</p><p>Vediamo come modificare la funzione <code>setRelais</code> e la funzione <code>resetRelais</code> in modo che lavorino nei corretti intervalli di tempo.</p><pre><code>int lastTimeRelaisWasReset = 0 ;      // when the Relais was set
#define MIN_SECONDS_RELAIS_SET 120  // two minutes before setting relais again

void relaisSet(){

    // calculate seconds passed from last time relais was resetted
    int deltaSeconds = Time.now() - lastTimeRelaisWasReset ;
    if (deltaSeconds &lt; MIN_SECONDS_RELAIS_SET) {
        // if not time is passed enough
        waitingForRelaisSet = true ; // yes, we are waiting for setting the relais
        return ; // exit function without setting relais
    }

    // we can set ralais position

    waitingForRelaisSet = false ;       // no, we are not waiting to set relais

    digitalWrite(D7,HIGH);    // signal on Photon led that relais is SET (Position A)
    digitalWrite(D4,HIGH);    // set PIN D4 high
    delay(100);                  // waits for 100 milliseconds
    digitalWrite(D4,LOW);     // set PIN D4 low
}

void relaisReset(){

    lastTimeRelaisWasReset = Time.now() ; // store seconds last time we set relais

    digitalWrite(D7,LOW);     // signal on Photon led that relais is RESET (Position B)
    digitalWrite(D3,HIGH);    // set PIN D3 high
    delay(100);               // waits for 100 milliseconds
    digitalWrite(D3,LOW);     // set PIN D3 low

}</code></pre><p>Per poter comunicare verso l’esterno che il relais dovrebbe portarsi in posizione A ma che stiamo aspettando per farlo, aggiungiamo alla funzione <code>setup</code> la pubblicazione della variabile <code>waitingForRelaisSet</code></p><pre><code>bool    heaterOn            = true  ;    // running mode
double  T                   = 0.0   ;    // temperature from sensor °C
double  Ts                  = 18.0  ;    // temperature setup °C
int     period              = 30000 ;    // milliseconds between each loop
int     relaisAorB          = 0     ;    // relais position: A=1, B=0, default B
bool    waitingForRelaisSet = false ;  // if the relais needs to be setted and we are waiting the right time

void setup(){

    temperatureHistoryInit() ;

    Particle.variable("heateron",heaterOn);
    Particle.variable("temperature",T);
    Particle.variable("tempsetpoint",Ts);
    Particle.variable("relaisaorb",relaisAorB);
    Particle.variable("waitrelais",waitingForRelaisSet) ;

    Particle.function("setheater",setHeaterMode) ;
    Particle.function("settemp",setTempSetpoint) ;

    pinMode(D3,OUTPUT);
    pinMode(D4,OUTPUT);

    pinMode(D7,OUTPUT);

    digitalWrite(D4, LOW);
    digitalWrite(D3, LOW);

    Wire.begin();
}</code></pre><p>Potete scaricare il codice modificato con la protezione delle accensioni, cliccando qui: <a href="https://github.com/techmakers/rotiliothermo/blob/master/firmware/rotiliothermo_step05.ino">rotiliothermo_step05.ino</a>.</p><p>Nota bene: dato che all’avviamento potrebbe essere chiamata la funzione <code>relaisReset</code>, anche la prima accensione verrà quindi “protetta”, non potendo così avvenire se non trascorsi i due minuti.</p><p>Da questo momento in avanti per sapere se il relais è realmente in posizione A, occorre quindi leggere entrambe le variabili <code>relaisAorB</code> e <code>waitingForRelaisSet</code>.</p><p>Se <code>waitingForRelaisSet</code> è vera allora il relè è sicuramente in posizione B, indipendentemente dal valore di <code>relaisAorB</code>.</p><p>Un effetto collaterale positivo che otteniamo con questa ultima modifica di protezione dell’accensione è anche la protezione del sistema dai seguenti casi:</p><ul>
        <li>utente che modifica, potremmo dire “gioca con”, le impostazioni del sistema cambiandole molto rapidamente</li>
        <li>più utenti, connessi allo stesso sistema, che ignari modificano le impostazioni in rapida successione</li>
    </ul><p>Il caso potrebbe essere quello in cui due componenti (X e Y) della famiglia impostano il riscaldamento.
        Supponiamo che Y decida di spegnere il riscaldamento e che trenta secondi dopo X decida di riaccenderlo, ecco che il relè verrebbe prima resettato (posizione B) e poi settato (posizione A), questo giochino, ripetuto N volte potrebbe dare problemi all’impianto.</p><p>La protezione appena introdotta risolve questo problema, ma non solo, ci proteggerà anche da eventuali errori dell’APP che andremo a costruire per pilotare da remoto il nostro impianto di riscaldamento.</p><h3 id="rotilio-thermo-prossimi-passi-inviamo-un-evento-sul-cloud-quando-accendiamo-o-spegnamo-il-riscaldamento">Inviamo un evento sul cloud quando accendiamo o spegnamo il riscaldamento</h3><p>Il cloud di Particle.io fornisce, oltre alla pubblicazione di variabili e funzioni, anche la pubblicazione di <strong>eventi</strong>.</p><p>Potete leggere un po’ di documentazione in merito alla pubblicazione di eventi a questo link: <a href=""></a><a href="https://docs.particle.io/reference/firmware/photon/#particle-publish-">https://docs.particle.io/reference/firmware/photon/#particle-publish-</a>.</p><p>Per pubblicare l’evento di accensione possiamo quindi inserire nella funzione <code>relaisSet</code> la chiamata a funzione <code>Particle.publish</code>, inviando un eveento denominato “relaisset”.</p><pre><code>void relaisSet(){

    // calculate seconds passed from last time relais was resetted
    int deltaSeconds = Time.now() - lastTimeRelaisWasReset ;
    if (deltaSeconds &lt; MIN_SECONDS_RELAIS_SET) {
        // if not time is passed enough
        waitingForRelaisSet = true ; // yes, we are waiting for setting the relais
        return ; // exit function without setting relais
    }

    // we can set ralais position

    waitingForRelaisSet = false ;       // no, we are not waiting to set relais

    digitalWrite(D7,HIGH);    // signal on Photon led that relais is SET (Position A)
    digitalWrite(D4,HIGH);    // set PIN D4 high
    delay(100);                  // waits for 100 milliseconds
    digitalWrite(D4,LOW);     // set PIN D4 low

    Particle.publish("relaisset");
}</code></pre><p>per pubblicare l’evento di spegnimento possiamo invece inserire la chiamata <code>Particle.publish</code> nella <code>relaisReset</code>, inviando un evento denominato “relaisreset”.</p><pre><code>void relaisReset(){

    lastTimeRelaisWasReset = Time.now() ; // store seconds last time we set relais

    digitalWrite(D7,LOW);     // signal on Photon led that relais is RESET (Position B)
    digitalWrite(D3,HIGH);    // set PIN D3 high
    delay(100);               // waits for 100 milliseconds
    digitalWrite(D3,LOW);     // set PIN D3 low

    Particle.publish("relaisreset"); // sends a "relaisreset" event to the cloud

}</code></pre><p>Per ricevere gli eventi pubblicati dal dispositivo attraverso il cloud di Particle.io, utilizziamo a piacimento il browser o il programma <code>curl</code>.</p><p>A questo url della GET http possiamo ricevere gli eventi:</p><pre><code class="lang-https://api.particle.io/v1/devices/36001b001551353531343431/events?access_token=cb60d9b2da2146bd7c2ede3c47f2c8523a95a825```">
Abbiate cura di sostituire ID del dispositivo e ACCESS_TOKEN con i vostri.

Se utilizzate il ```curl``` in una finestra di terminale</code></pre><p>curl <a href="https://api.particle.io/v1/devices/36001b001551353531343431/events?access_token=cb60d9b2da2146bd7c2ede3c47f2c8523a95a825">https://api.particle.io/v1/devices/36001b001551353531343431/events?access_token=cb60d9b2da2146bd7c2ede3c47f2c8523a95a825</a></p><pre><code>
in poco tempo otterrete quanto segue</code></pre><p>:ok</p><p>event: relaisreset
        data: {”data”:”null”,”ttl”:60,”published_at”:”2017-09-24T21:45:43.182Z”,”coreid”:”36001b001551353531343431”}</p><p>event: relaisreset
        data: {”data”:”null”,”ttl”:60,”published_at”:”2017-09-24T21:46:13.298Z”,”coreid”:”36001b001551353531343431”}</p><p>event: relaisreset
        data: {”data”:”null”,”ttl”:60,”published_at”:”2017-09-24T21:46:43.413Z”,”coreid”:”36001b001551353531343431”}</p><p>event: relaisreset
        data: {”data”:”null”,”ttl”:60,”published_at”:”2017-09-24T21:47:13.535Z”,”coreid”:”36001b001551353531343431”}</p><p>event: relaisreset
        data: {”data”:”null”,”ttl”:60,”published_at”:”2017-09-24T21:47:43.660Z”,”coreid”:”36001b001551353531343431”}</p><pre><code>
Potrete quindi notare, che ogni 30 secondi, viene inviato un evento "relaisreset", si può capire dalla data del dato "published_at".

Come potrete immaginare, questo non è corretto e mette in evidenza un difetto del nostro firmware.

Le funzioni ```relaisSet``` e ```relaisReset``` vengono chiamate sempre, anche se il relè è già nella posizione giusta.

Di per sè questo non è un problema, ma causa due cose:

1. il dispositivo invia "falsi" eventi al cloud
2. le bobina del relè vengono eccitate comunque almeno ogni 30 secondi, con uno spreco di corrente che, in applicazioni alimentate a batteria, sono la fine del progetto ancor prima di iniziarlo.

Dobbiamo quindi prevenire inutili chiamate alle funzioni ```relaisset``` e ```relaisreset```.

Per fare questo dobbiamo memorizzare lo stato del relè in una variabile 
```relaisIsSet``` dichiarata all'inizio del codice,</code></pre><p>bool    relaisIsSet         = true  ;    // we will test this before really calling the relaisSet or relaisReset functions</p><pre><code>

impostarla correttamente ogni volta che chiamiamo le funzioni ```relaisSet``` e ```relaisReset</code></pre><pre><code>void relaisSet(){

    // calculate seconds passed from last time relais was resetted
    int deltaSeconds = Time.now() - lastTimeRelaisWasReset ;
    if (deltaSeconds &lt; MIN_SECONDS_RELAIS_SET) {
        // if not time is passed enough
        waitingForRelaisSet = true ; // yes, we are waiting for setting the relais
        return ; // exit function without setting relais
    }

    // we can set ralais position

    waitingForRelaisSet = false ;       // no, we are not waiting to set relais 

    digitalWrite(D7,HIGH);    // signal on Photon led that relais is SET (Position A)
    digitalWrite(D4,HIGH);    // set PIN D4 high
    delay(100);                  // waits for 100 milliseconds
    digitalWrite(D4,LOW);     // set PIN D4 low

    relaisIsSet = true ;

    Particle.publish("relaisset"); // sends a "relaisset" event to the cloud
}

void relaisReset(){

    lastTimeRelaisWasReset = Time.now() ; // store seconds last time we set relais

    digitalWrite(D7,LOW);     // signal on Photon led that relais is RESET (Position B)
    digitalWrite(D3,HIGH);    // set PIN D3 high
    delay(100);               // waits for 100 milliseconds
    digitalWrite(D3,LOW);     // set PIN D3 low

    relaisIsSet = false ; 

    Particle.publish("relaisreset"); // sends a "relaisreset" event to the cloud

}</code></pre><p>e verificare nel <code>loop</code> lo stato della variabile prima di chiamare realmente le funzioni suddette.</p><pre><code>    if (relaisAorB == 1) {
        if (!relaisIsSet) relaisSet();           // switch relais to position A
    } else {
        if (relaisIsSet) relaisReset();         // switch ralais to position B
    }</code></pre><p>Potete scaricare il codice modificato con la pubblicazione degli eventi, cliccando qui: <a href="https://github.com/techmakers/rotiliothermo/blob/master/firmware/rotiliothermo_step07.ino">rotiliothermo_step06.ino</a>.</p><p>Potete adesso provare a modificare le impostazioni di temperatura per testare tutto il sistema.</p><p>Se non lo avete ancora fatto, potete utilizzare la comodissima console che Particle.io mette a disposizione per testare il firmware dei dispositivi, la trovate a questo link: <a href=""></a><a href="https://console.particle.io/devices/">https://console.particle.io/devices/</a>.</p><p>Si presenterà l’elenco dei device associati al vostro account Particle.io (lo avevate creato quando avete collegato per la prima volta un Photon alla rete WiFi).</p><p>Cliccando sul dispositivo potrete accedere all’elenco di variabili e funzioni, nonchè ricevere gli eventi pubblicati dal dispositivo stesso.</p><p>Avrei potuto indicarvi prima l’esistenza di questa utility ma ho preferito mostrarvi gli strumenti che, tramite chiamate http, saranno la base per costruire la nostra APP di controllo del riscaldamento nel prossimo tutorial.</p><h2 id="rotilio-thermo-lapp-mobile">L’APP Mobile</h2><p>Stiamo preparando il tutorial interamente dedicato all’APP Mobile, torna presto a trovarci, oppure contattaci per avere informazioni in merito.</p></div>
</div>


</body></html>